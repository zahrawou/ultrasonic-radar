# What is this ?
A compact ultrasonic radar implementation running on an embedded Linux SoC, featuring a single Python file architecture that renders graphics directly to the Linux framebuffer with remote access capability via VNC client.

[![Watch the video](https://img.youtube.com/vi/6gdzUYV3WLg/0.jpg)](https://www.youtube.com/watch?v=6gdzUYV3WLg)

# Hardware
* Luckfox pico mini b (Rockchip RV1103 SoC)
* HC-SR04 Ultrasound module (that supports UART mode)
* 9g servo motor
* Wires, capacitors and USB cable

# How does it works ?
The Python script controls the servo motor via the SoC's PWM pin while receiving ultrasonic measurements through UART from the sensor module, simultaneously rendering and updating the radar display on the Linux framebuffer. Additionally, it runs an X11 VNC server, enabling remote viewing from any device with a VNC client, including computers, tablets, and phones, by streaming the framebuffer content over the network. In my case the SoC is in host mode and have a tiny USB Wifi dongle.

# Can I use any ultrasound module ?
<img width="432" height="413" alt="image" src="https://github.com/user-attachments/assets/c928fe80-5712-4dc5-b733-29ba6139d1c5" />
<img width="432" height="413" alt="image" src="https://github.com/user-attachments/assets/5461cb73-8472-4d6a-a567-35e5e34888ad" />

> [!WARNING]
> Enable UART mode by following the instructions table on the PCB and solder the shown pad, in this case M1 only. If yours don't have any of those things, it may only support the GPIO pulse method.

Since Linux cannot guarantee high-precision timing due to its preemptive kernel scheduler, the script uses the sensor's UART mode instead of the traditional GPIO pulse method. In UART mode, the sensor handles all the timing calculations internally. To initiate a measurement:  
1. Send the trigger command `0xA0` via UART
2. The module automatically emits the ultrasound and processes the echo
3. Wait for the response with a timeout
4. If no object is detected or the signal is completely deflected, the module returns no data, and we simply skip that measurement

When successful, the module returns exactly 3 bytes. Combining these bytes and converting to decimal gives the distance measurement directly in micrometers (µm).

# Configuration and wiring
Both UARTs should be configured for 9600 bps 8N1 communication. The ultrasonic sensor can use 3.3V for simplicity since the SoC operates at the same voltage level, while the servo motor requires 5V which can be sourced directly from the USB VBUS line. To prevent system instability, it's crucial to add decoupling capacitors between VCC and GND lines to filter out electrical noise generated by the servo motor, which could otherwise cause the SoC to reset or freeze. Here is the circuit layout:  

<img width="1417" height="297" alt="image" src="https://github.com/user-attachments/assets/42e812ad-ddea-429a-96e1-c10a036c8129" />

```
SoC        SR04       Servo
────────────────────────────
3V3  ─────→ VCC
VBUS ────────────────→ VCC
GND  ───┬→ GND
        └────────────→ GND  
P53  ─────→ RX
P52  ─────→ TX
P54  ────────────────→ PWM

Power:
SoC 3V3  → SR04 VCC
SoC VBUS → Servo VCC
SoC GND  → SR04 GND → Servo GND

Signals:
SoC Pin 53 → SR04 RX
SoC Pin 52 → SR04 TX  
SoC Pin 54 → Servo PWM
```

# Will this work for my project ?
The code is designed for easy portability with most parameters configurable at the top of the file. Both PWM and UART interfaces operate at the OS level, typically accessed through Linux device nodes like `/dev/pwm*` and `/dev/tty*`, but since the script uses the periphery library, that should take care of how to access them.

# How to run ?
Since I am using Buildroot Linux OS, all the requisites can be installed using its menuconfig, present in the Luckfox pico SDK.

## Pre-requisites
1. Python 3 installed
2. This lib: `pip install python-periphery`
3. A framebuffer at `/dev/fb*`
4. Framebuffer set with a low resolution and 16 bits color: `fbset -g 320 240 320 240 16`
5. X11 VNC server binary: `x11vnc`

## Running
1. Run the tool: `python3 radar.py`
2. Run the VNC server: `x11vnc -rawfb console -auth /dev/null -noxdamage -forever -shared -repeat -defer 0 -wait 0 -noxinerama -nowf -nowcr -speeds modem -tightfilexfer`
3. Connect to the server IP with a VNC client (ex: Remmina on Ubuntu)

You should see this:  
![radar](https://github.com/user-attachments/assets/76c4510f-335f-4e3b-9d78-f80d20bad500)

> [!NOTE]
> Each gray ring represents 30cm distance

# Features and tips
* Give enough time for the ultrasonic module process the echo and return, if you go too fast the readings will be off
* Some materials can absorb and/or deflect ultrasounds to random directions so that they never return to the receptor, therefore timing out the reading
* The script detect the framebuffer resolution and color automatically to draw, but use lower resolutions and colors for faster drawing specially when streaming over wifi
* By default the script is using the UART4 and PWM10
* By narrowing the angle like START_ANGLE=45 and END_ANGLE=135 the drawing will adapt accordingly
* Althought the SR04 is rated at 4m max distance, keep it MAX_DISTANCE_CM to something lower to have more zoom in the radar and honestly it cannot read at 4m
* For better range and speed supply the SR04 with 5v instead of 3.3v, but careful to not burn the SoC by converting its signal to something compatible with whatever IC you may be using
* Make sure your servo support the chosen START_ANGLE and END_ANGLE, some servos are 90 degress only, while others are 180 and even 360
* All the drawing colors can be changed
* The framebuffer path can be changed, in case you wanna render only to a specific framebuffer and not the main one where the VNC console may be running
* The framebuffer can be displayed in any connected screen via HDMI, SPI or whatever display may be present, and use any existing framebuffer tools like `fbgrab` to take a screenshot, stream over network and record videos
